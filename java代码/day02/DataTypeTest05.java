/*
	关于java中的整数型
		byte
		short
		int
		long
*/
public class DataTypeTest05{

	public static void main(String[] args){
		
		// 100L是long类型字面值
		// x是long类型变量
		// 不存在类型转换，直接赋值
		long x = 100L;

		// x变量是long类型，8个字节
		// y变量是int类型，4个字节
		// 以下程序可以编译通过吗？
		// 编译报错：大容量不能直接赋值给小容量
		// int y = x;

		// 大容量转换成小容量，需要进行强制类型转换
		// 强制类型转换需要“加强制类型转换符”
		// 加上强制类型转换符之后，编译通过了，但是运行阶段可能损失精度
		// 所以强制类型转换谨慎使用，因为损失精度之后，可能损失很严重

		// 强转原理：
			// 原始数据：00000000 00000000 00000000 00000000 00000000 00000000 00000000 01100100
			// 强转之后的数据：00000000 00000000 00000000 01100100
			// 将左边的二进制砍掉【所有的数据，强转的时候都是这样完成的】
		int y = (int)x;
		System.out.println(y);

		// 原始数据：00000000 00000000 00000000 00000000 10000000 00000000 00000000 00000000
		// 强转之后的数据：10000000 00000000 00000000 00000000 // 补码形式
		// 10000000 00000000 00000000 00000000 目前存储在计算机内部，计算机存储数据，都是采用补码的形式存储
		// 所以 10000000 00000000 00000000 00000000 是一个补码形式
		// 将以上的补码转换到原码就是最终的结果
		long k = 2147483648L;
		int e = (int)k;
		System.out.println(e); // 损失精度，结果是负数【-2147483648】

		// 分析以下程序是否可以编译通过？
		// 依据目前所学内容，以下程序是无法编译通过的
		// 理由：50是int类型的字面值，b是byte类型的变量，显然是大容量int转换成小容量byte
		// 大容量转换成小容量是需要添加强制类型转换符的，以下程序没有添加强转符号，所有编译报错
		// 但是，在实际编译的时候，并没有报错，这说明：在java语言当中，当一个整数型字面值没有超出byte类型取值范围的话，该字面值可以直接赋值给byte类型的变量
		byte b = 50;  // 可以
		System.out.println(b); // 50

		byte c = 127; // 可以
		System.out.println(c); // 127

		// byte b1 = 128; // 不可以，超过了byte类型的取值范围，不能直接赋值给byte类型的变量

		// 纠正错误，需要使用强制类型转换符
		// 但一定会损失精度
		// 原始数据：00000000 00000000 00000000 10000000
		// 强转之后：10000000【这是存储在计算机内部的，是一个补码，它的原码是什么？】
		byte b1 = (byte)128;
		System.out.println(b1); // -128

		/*
			计算机二进制有三种表示形式：
				原码
				反码
				补码
			计算机在任何情况下，底层表示和存储数据的时候，采用的都是补码形式
			正数的反码，补码，和原码相同
			负数的补码；是负数原码取反（符号位不变，其他位取反），再加1
			由补码推原码的时候，原码最终的符号位向补码看齐，即一个数的正负由补码的符号位决定
		*/


		// 原始数据：00000000 00000000 00000000 11000110
		// 强制类型转换之后：11000110
		// 11000110现在在计算机中存储，它是一个补码，将补码转换成原码就是该数字
		// 反码：11000110 -1 --> 11000101
		// 原码：00111010【2 + 8 + 16 + 32】--> -58，计算机以为它是正数，其实是负的
		byte m = (byte)198;
		System.out.println(m); // -58

		// short s = 32767; // 通过
		// short s1 = 32768; // 报错

		// 65535是int类型，4个字节
		// cc是char类型，2个字节
		// 按照以前所学的知识点来说，以下程序是报错的
		char cc = 65535; // 编译通过
		char cc = 65536; // 编译报错

		/*
			当一个整数字面值没有超出byte,short,char的取值范围时，这个字面值可以直接赋值给byte,short,char类型的变量，这种机制SUN允许了，目的是为了方便程序员的编程
		*/

	}
}

